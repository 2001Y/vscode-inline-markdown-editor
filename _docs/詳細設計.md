## VS Code Inline Markdown Editor（Tiptap）詳細設計

- **対象**: VS Code 拡張（Custom Text Editor + Webview）
- **目的**: Markdown（`.md`）を開いた瞬間から「プレビューと編集を分離せず」Tiptap 上で **表示＝編集** できる体験を提供する
- **保存形式**: 既存どおり **Markdown テキスト（VS Code `TextDocument`）** を唯一の真実として保持する
- **ステータス**: Draft
- **更新日**: 2026-01-06

---

### 1. 現象ベースの要約（要件の言い換え）

- **ユーザーが `.md` を開いた瞬間**に、標準のテキストエディタではなく **Webview（Tiptap）** がエディタ領域に表示される
- 編集結果は即時（または短い遅延で） **`TextDocument` の Markdown テキスト**へ同期され、通常の保存・Undo/Redo・Hot Exit の恩恵を受ける
- Split 表示時は「`TextDocument` は 1 つ、Webview は複数」になり得るため、**全 Webview が同一ドキュメント状態**に収束する

---

### 2. ゴール / 非ゴール

#### 2.1 ゴール

- **G1**: `.md` を Webview（Tiptap）で開ける（CustomTextEditorProvider）
- **G2**: Webview 編集 ⇄ `TextDocument` の双方向同期（ループ無し・複数 Webview 対応）
- **G3**: CSP / localResourceRoots / asWebviewUri を用いた **安全な Webview**（外部リソース非依存）
- **G4**: Undo/Redo の体験が破綻しない（最低限、タイプ入力が過剰に分割されない）
- **G5**: 既存 Markdown の不要な再整形を **最小化**する（G5-lite）
  - 差分は最小変更に分解して適用し、過大な書き換えは確認/停止の導線を提供する
- **G6**: テーマ追従（VS Code の色/フォントに馴染む）

#### 2.2 非ゴール（初期版では扱わない）

- **NG1**: あらゆる Markdown 方言（frontmatter/独自記法/コメント等）の完全保全
  - 初期実装の「対応範囲」は **Tiptap のスキーマ + MarkdownCodec + 本設計の RAW ブロック/セキュリティ方針**で定まる
  - 対応範囲外の要素は RAW として保持するが、完全な意味保持/ラウンドトリップ保証は行わない（=NG1）
- **NG3**: リアルタイム共同編集（CRDT 等）

---

### 3. 想定される失敗要因（原因候補）と優先度

要件は「TextDocument と Webview の二重世界」を扱うため、失敗パターンがほぼ決まっています。影響度（壊れ方の大きさ）と発生頻度（起きやすさ）で優先度を付けます。

- **P0（影響:大 / 頻度:高） 無限ループ / 二重反映**
  - 例: Webview → applyEdit → onDidChangeTextDocument → Webview 更新 → Webview が再投稿…のループ
- **P0（影響:大 / 頻度:高） バージョン不整合（複数 Webview/Undo/外部編集）**
  - 例: Webview が古い状態を前提に差分を送って破壊的適用、または意図しない上書き
- **P0（影響:大 / 頻度:中） CSP/リソース読み込み失敗**
  - 例: `asWebviewUri` 未使用、localResourceRoots 不備、nonce/CSP 不整合で JS が動かない
- **P1（影響:中 / 頻度:高） Undo/Redo 粒度が悪い**
  - 例: 1 文字ごとに undo step が増える／全文置換で undo が粗すぎる
- **P1（影響:中 / 頻度:中） Markdown 互換性の欠落（frontmatter/表/HTML 等）**
  - 例: 変換で失われる、保存すると壊れる
- **P2（影響:中 / 頻度:中） パフォーマンス劣化（大きい md / 画像 / 連打）**
  - 例: 全文置換で重い、postMessage が多すぎる
- **P2（影響:小〜中 / 頻度:中） Webview ライフサイクル（破棄/復帰）で状態が飛ぶ**

このうち **最優先で設計に織り込むべき（根拠あり）**は次の 3 つです。

- **最優先 1: 無限ループ防止**（発生頻度が高く、起きると編集不能になる）
- **最優先 2: バージョン整合（baseVersion + txId）**（複数 Webview/Undo/外部編集で必ず必要）
- **最優先 3: CSP/リソース方針**（動かないと検証すらできない）

---

### 4. 全体アーキテクチャ

#### 4.1 主要コンポーネント

- **Extension Host（Node/TypeScript）**
  - VS Code API を使い Custom Editor を提供
  - `TextDocument` を単一の真実（source of truth）として管理
  - Webview と message passing で同期
- **Webview（ブラウザ環境）**
  - Tiptap を起動し、Markdown をリッチ表示＆編集
  - **セッション内の編集状態**は Tiptap/ProseMirror の doc（JSON）として保持する（`editor.getJSON()` 相当）
    - 永続化/権威は常に `TextDocument` の Markdown（Webview は Markdown に追従して再構築できること）
    - Markdown 入出力は MarkdownCodec で行い、HTML は経由しない（HTML はデフォルト RAW 扱い、必要ならオプションで安全にレンダリング）
  - 変更を “編集要求（request）” として拡張へ送る
  - 拡張からの “ドキュメント変更通知（docChanged）” を適用する

#### 4.2 設計原則（壊れにくさのための制約）

- **原則 A: 真実は常に `TextDocument`**
  - Webview は「入力と表示」を担うが、確定は `workspace.applyEdit()` の結果として `TextDocument` に入る
- **原則 B: Webview 更新通知は `onDidChangeTextDocument` 起点に統一**
  - 「applyEdit の直後に独自通知」+「onDidChange でも通知」の二重系を避け、二重適用や順序バグを防ぐ
- **原則 C: 整合性は `baseVersion` + `txId` で担保**
  - Webview からの編集要求は **“どの `TextDocument.version` を前提にした差分か”**を必須とする

#### 4.3 ポリシー（必須）

- **フォールバック禁止**: 自動で標準テキストエディタへ切り替えない（問題は UI 上に顕在化させる）
- **サイレントリカバリ禁止**: 失敗を隠して「それっぽく直す」をしない（ログとともにエラーを表示する）
- **不整合は “完全リセット”**: 状態が壊れたらセッションを破棄して再初期化する（Reset 導線を提供）
- **完全ログ主義**: 原因特定に必要な入出力（プロトコル/分岐/タイムアウト等）を記録できるようにする
- **整形保持（G5-lite）**: 不要な再整形を最小化し、疑わしい大規模変更は検出・再現可能にする（必要なら確認/停止する）
- **セキュリティ優先**: Webview は外部通信なし（デフォルト）・成果物同梱・最小 CSP を前提にする（8.4）。必要な場合のみ明示的に緩める（例: リモート画像）

---

### 5. 拡張の提供形態（Custom Editor の登録方針）

#### 5.1 viewType（識別子）

- 例: `inlineMarkdownEditor.editor`

#### 5.2 対象ファイル（selector）

- 初期: `*.md`
- 将来: `.mdx` 等を追加する場合は別 viewType に分ける（互換性差が大きいため）

#### 5.3 priority（置換の強さ）

本プロジェクトの方針は **`default`** です（`.md` を開いた瞬間から本エディタで開く）。

- **default**: `.md` を基本的に本エディタで開く（強いが、本プロジェクトでは採用）
- **option**: 「Reopen With...」等で選べる状態にし、徐々に検証（採用しない方針）

※ `default` であっても、ユーザーは VS Code の editor associations（例: `workbench.editorAssociations`）で標準テキストエディタへ戻せます。

---

### 6. 提案ディレクトリ構成と責務分割（実装時の青写真）

現状は設計のみのリポジトリですが、実装開始時に次の構成へ拡張することを推奨します。

#### 6.1 ルート構成（提案）

```
repo/
  packages/
    extension/            # Extension Host（Node）
      src/
        extension.ts
        editors/
          inlineMarkdownEditorProvider.ts
        protocol/
          messages.ts
        util/
          textEdits.ts
          log.ts
      media/
        webview/          # Webview build 出力先（配布物）
    webview/              # Webview app（Tiptap）
      src/
        main.ts
        editor/
          createEditor.ts
          markdownCodec.ts
        protocol/
          client.ts
          types.ts
```

#### 6.2 各ファイルの責務（明確化）

- `packages/extension/src/extension.ts`
  - **責務**: 拡張のエントリ。provider 登録、コマンド登録、設定読み取り
- `packages/extension/src/editors/inlineMarkdownEditorProvider.ts`
  - **責務**: `CustomTextEditorProvider` 実装、Webview HTML 生成、パネル管理、docChanged ブロードキャスト
- `packages/extension/src/protocol/messages.ts`
  - **責務**: 拡張側で扱う message 型・バリデーション（最低限の型ガード）
- `packages/extension/src/util/textEdits.ts`
  - **責務**: offset↔Range 変換、`WorkspaceEdit` 生成、差分正規化（非重複化/統合）
- `packages/extension/src/util/log.ts`
  - **責務**: OutputChannel ロガー（設定で on/off・詳細度切替）
- `packages/webview/src/main.ts`
  - **責務**: `acquireVsCodeApi()` 初期化、message loop 起動、アプリの root をマウント
- `packages/webview/src/editor/createEditor.ts`
  - **責務**: Tiptap Editor インスタンス生成、ユーザー入力イベント → 編集要求生成
- `packages/webview/src/editor/markdownCodec.ts`
  - **責務**: Markdown ⇄ Tiptap doc 変換（初期は自前 Codec。将来 `@tiptap/markdown` / `prosemirror-markdown` への移行を検討）
- `packages/webview/src/protocol/client.ts`
  - **責務**: `ready/init/docChanged/ack/nack` 等のハンドシェイク、version/tx 管理、resync

#### 6.3 各ファイル先頭の責務コメント（運用ルール）

実装開始時、**上記の主要ファイルは先頭に役割コメントを必ず付与**します（後からの保守のため）。

```ts
/**
 * 役割: 〜〜〜
 * 責務: 〜〜〜（このファイルが“やること/やらないこと”）
 * 不変条件: 〜〜〜（例: TextDocument が唯一の真実 / docChanged は onDidChange 起点）
 */
```

#### 6.4 内部コンポーネント分割（具体案）

「ただ動く」だけでなく、同期/ログ/Reset を壊さずに実装するため、責務を次に分割する。

- **Extension Host 側**

  - **InlineMarkdownEditorProvider**: CustomTextEditorProvider。本体の入口。Webview HTML 注入、パネル登録/破棄、docChanged 配信
  - **DocumentCoordinator**: `docUri` ごとの状態とパネル一覧を保持し、`onDidChangeTextDocument` を起点にブロードキャストする
    - 重要: edit の適用は **queue しない**（方針）。不整合は `nack(reason=baseVersionMismatch)` → resync で解消する
  - **MessageBridge**: `onDidReceiveMessage` を受け、型検証 → ルーティング → ログ化（不正メッセージは無視/エラー化）
  - **EditApplier**: Replace[] を `WorkspaceEdit` に変換して適用する（offset→Range、正規化、失敗理由の整形）
  - **WebviewHtmlFactory**: `manifest.json` を読み、`asWebviewUri` と CSP（nonce）を適用した HTML を生成する
    - CSP は設定（例: `security.allowRemoteImages`, `security.allowInsecureRemoteImages`, `security.renderHtml`）に応じて最小許可で組み立てる
  - **Config**: 設定値の読み取りとデフォルト管理（debounceMs/timeoutMs/log level 等）
  - **Logger**: OutputChannel + JSONL への記録（必要に応じて Webview からの logClient も収集）

- **Webview 側**
  - **EditorCore**: Tiptap の起動と extension 構成
  - **MarkdownCodec**: Markdown ⇄ Tiptap doc 変換（初期は自前 Codec。対応範囲は `test-fixtures/test.md` を最低限満たす）
  - **MarkdownSnapshotter**: `shadowText`（最後に同期できた Markdown）と `nextMarkdown`（現在の editor 状態を serialize した Markdown）を管理する
  - **DiffEngine**: `shadowText -> nextMarkdown` を diff-match-patch 等で比較し、Replace[]（0..N 件）を生成する
  - **ChangeGuard**: 変更量が大きすぎる場合は自動適用せず、**VS Code 標準通知 UI** に警告を出す（`notifyHost`）
  - **SyncAgent**: debounce/in-flight/coalesce/timeout、docChanged の適用、requestResync、エラー通知（`notifyHost`）
  - **ClientLogger**: Webview 内の診断ログを `logClient` として拡張へ送る（デバッグオプション: `debug.enabled=true` の時のみ）

補足（P2-1）：

- 初期実装では “抽象化のための抽象化” を避け、まず **Provider + Coordinator + Codec + Logger + SyncAgent** の最小構成で同期成立を優先する
- 安定後に `MessageBridge` / `WebviewHtmlFactory` / `EditApplier` 等を段階的に抽出してもよい

---

### 7. Webview のビルド/配置方針

#### 7.1 方針（推奨）

- Webview は **外部 CDN に依存しない**（オフラインで完結）
- バンドラは **Vite を第一候補**（運用が簡単、成果物配置も明確）
- 出力先は `packages/extension/media/webview/`（拡張配布物に同梱）

#### 7.2 出力ファイル名と manifest

- Vite の `manifest.json` を利用し、ハッシュ付きファイル名にも追従できる設計を推奨
  - 拡張側で manifest を読み、`isEntry` の chunk を特定し、`file`（JS）と `css[]`（CSS）を `asWebviewUri` 化する

#### 7.3 解決策（推奨のビルド運用）

Webview は **ビルド済み成果物を拡張に同梱**し、Webview 側で外部通信しない前提（デフォルト）で運用する。
（例外: リモート画像許可を明示的に有効化した場合のみ `img-src` を緩める）

- **配布（prepublish）**:
  - `packages/webview` を `vite build` して `packages/extension/media/webview/` に出力
  - その後 `packages/extension` をビルド（例: `tsc`）
- **開発**:
  - Webview は `vite build --watch` 等で成果物を更新（dev server に頼らない）
  - 拡張も watch ビルド（例: `tsc -w`）で更新

---

### 8. Webview HTML 生成・CSP・リソース制約（セキュリティ設計）

#### 8.1 localResourceRoots / asWebviewUri

- `localResourceRoots` はデフォルトで **`media/webview` のみに限定**する
- ただし **ワークスペース内画像を表示する**ため、ワークスペースが trusted かつ許可設定が有効な場合は `workspaceFolders` を追加で許可する（P0-5 対応）
- HTML 内の JS/CSS/画像/フォント参照は **必ず `webview.asWebviewUri()`** を使う

#### 8.2 CSP（推奨テンプレ）

基本は **`default-src 'none'`** から始め、必要最小限のみ許可します。

- 画像貼り付け等のため、`img-src` に `data:` を許可する（不要なら閉じる）
- script は **nonce** を使う
- `style-src` は原則 **`unsafe-inline` なし**で開始する（P0-3 対応）
  - どうしても必要な機能（例: style 属性を出す extension）を有効化した場合のみ、例外として `style-src 'unsafe-inline'` を追加する（理由と影響を設計に明記）
- リモート画像許可（オプション）を有効化した場合のみ、`img-src` に `https:`（必要なら allowlist）を追加する
  - `security.allowInsecureRemoteImages=true` の場合は追加で `http:` も許可する（強い非推奨）

```html
<meta
  http-equiv="Content-Security-Policy"
  content="
  default-src 'none';
  base-uri 'none';
  form-action 'none';
  frame-ancestors 'none';
  img-src ${webview.cspSource} data:;
  font-src ${webview.cspSource};
  style-src ${webview.cspSource};
  script-src 'nonce-${nonce}' ${webview.cspSource};
"
/>
```

#### 8.3 解決策（CSP とバンドルの相性で詰まらないために）

- **script-src**:
  - `script-src 'nonce-${nonce}' ${webview.cspSource};` を採用する
  - 理由: バンドラのコード分割（動的 import）で追加チャンクを読み込む場合でも破綻しにくい
- **unsafe-eval を避ける**:
  - production 配布はビルド成果物のみを読み込む（dev server を前提にしない）
- **外部通信を不要にする**:
  - Webview から外部 fetch をしない（`connect-src` を開けない）前提にする
  - 依存（Tiptap 等）はバンドルして同梱する

#### 8.4 安定化チェック（今回の前提の明文化）

本プロジェクトでは次を **デフォルト前提**として固定する（「安定化」要件）。必要な場合のみ明示的に緩める。

- **外部通信なし（デフォルト）**:
  - Webview から外部ネットワークへはアクセスしない（フォント/CDN/analytics を含む）
  - 例外: **リモート画像許可（オプション）**を有効化した場合のみ `img-src` を緩める（12.3 / 18. セキュリティ参照）
    - `security.allowRemoteImages=true`: `img-src https:`
    - `security.allowInsecureRemoteImages=true`: 追加で `img-src http:`（強い非推奨）
- **ビルド成果物同梱**:
  - Webview の JS/CSS/asset は `packages/extension/media/webview/` に同梱する
- **manifest で参照解決**:
  - 拡張は `manifest.json` を読み、エントリの JS/CSS を解決して `asWebviewUri` 化する
- **CSP は nonce + `${webview.cspSource}`**:
  - `script-src 'nonce-${nonce}' ${webview.cspSource};` を固定し、コード分割があっても破綻しないようにする

---

### 9. メッセージプロトコル（Webview ⇄ Extension）

#### 9.1 目的

- **複数 Webview** と **外部変更（Undo/他エディタ/拡張）** を前提に壊れない同期を行う
- 編集要求は「どのバージョンに対する差分か」を明示し、適用失敗時は resync できるようにする

#### 9.2 共通エンベロープ（必須/推奨）

- **必須**
  - `v`: プロトコルバージョン（例: `1`）
  - `type`: メッセージ種別
- **推奨（診断/将来互換のため）**
  - `ts`: 送信時刻（ms）
  - `origin`: `webview` | `extension`
  - `sessionId`: セッション識別子（extension が採番し、`init` で webview へ配布）
  - `clientId`: Webview インスタンス識別子（split 対応。extension が採番し、`init` で webview へ配布）
  - `docUri`: 対象ドキュメント URI（診断用。**webview→extension では信頼しない**）

補足（P1-2 対応）：

- Extension 側は `resolveCustomTextEditor(document, panel)` により「この panel がどの document か」を把握しているため、webview から来た `docUri` を信頼しない（送ってきても照合のみ）。

#### 9.3 変更表現（推奨）

Webview → 拡張の編集要求は、最終的に VS Code の `TextEdit` に落としやすい **Replace（offset 範囲置換）配列**で表現します。

- `start/end` は UTF-16 offset（VS Code の `positionAt/offsetAt` 互換）
- `docChanged`（`TextDocumentContentChangeEvent`）から生成する場合、`rangeOffset/rangeLength` は **変更前ドキュメント基準**の offset なので、この値を優先して Replace を作る（ズレ防止）
- `changes` は **互いに非重複**、原則 **昇順**

#### 9.4 メッセージ一覧（最小で堅牢）

- **Webview → Extension**
  - `ready`: 初期ハンドシェイク
  - `edit`: 編集要求（`baseVersion` + `changes`）
  - `requestResync`: 同期の取り直し要求
  - `logClient`: Webview 内ログの送信（デバッグオプション: `debug.enabled=true` の時のみ送る）
  - `openLink`: リンクを開く要求（危険スキーム拒否 + `vscode.env.openExternal`）
  - `resolveImage`: ワークスペース内画像の解決要求（`asWebviewUri` で返す）
  - `notifyHost`: VS Code 標準の通知 UI に表示したい警告/エラー（ChangeGuard 等）
- **Extension → Webview**
  - `init`: 初期化（全文 + `version`）
  - `docChanged`: `TextDocument` 変更通知（差分 + `version`）
  - `ack`: 編集要求の受理/確定（in-flight 解放。変更が 0 でも返す）
  - `nack`: 編集要求の拒否（baseVersion 不一致など）
  - `error`: 復旧が必要なエラー通知（Reset 導線のため）
  - `imageResolved`: `resolveImage` の結果（解決済み src を返す）

例（概念）：

```json
{ "v": 1, "type": "ready" }
```

```json
{
  "v": 1,
  "type": "edit",
  "txId": 101,
  "baseVersion": 12,
  "changes": [{ "start": 120, "end": 125, "text": "abc" }]
}
```

```json
{
  "v": 1,
  "type": "ack",
  "txId": 101,
  "currentVersion": 13,
  "outcome": "applied"
}
```

```json
{
  "v": 1,
  "type": "nack",
  "txId": 101,
  "currentVersion": 13,
  "reason": "baseVersionMismatch"
}
```

```json
{
  "v": 1,
  "type": "docChanged",
  "version": 13,
  "reason": "external",
  "changes": [{ "start": 120, "end": 125, "text": "abc" }]
}
```

```json
{
  "v": 1,
  "type": "logClient",
  "level": "debug",
  "message": "serialize completed",
  "details": { "txId": 101, "nextLength": 12345 }
}
```

```json
{
  "v": 1,
  "type": "error",
  "code": "SYNC_TIMEOUT",
  "message": "ack/nack が一定時間届きませんでした",
  "remediation": ["resetSession", "reopenWithTextEditor"]
}
```

#### 9.5 重要な運用ルール（破綻防止）

- **ルール 1: docChanged は `onDidChangeTextDocument` 起点に統一**
  - applyEdit 直後に “自前で docChanged” を送らない（二重通知を防ぐ）
- **ルール 2: baseVersion 不一致の edit は原則 reject（nack）**
  - “今の document に当ててみる” は split/Undo/外部編集で破綻しやすい
- **ルール 3: Webview は docChanged 適用中に edit を送らない**
  - `applyingRemote` フラグ等で抑止し、ループを断つ
- **ルール 4: in-flight は client ごとに 1 件まで（キュー/リベース無し）**
  - in-flight 中に追加の編集が発生した場合は「送信せずに coalesce」し、in-flight 解消後に **最新状態を 1 回だけ** flush する
    - `ack(outcome=noop)` の場合は ack 後に flush
    - `ack(outcome=applied)` の場合は **対応する `docChanged` 適用後**に flush（shadowText が確定してから差分を再計算する）

#### 9.6 タイムアウトと復旧（ack あり）

- Webview は `edit` 送信後、**一定時間（timeoutMs）以内に `ack` / `nack` を受け取れない**場合、同期が詰まったと判断する
- `ack` は「in-flight 解放」のために必須で、**変更が 0（no-op）でも返す**（P0-4 対応）
- 詰まり時は `requestResync` を試み、それでも回復しなければ **VS Code 標準通知 UI** で `SYNC_TIMEOUT` を表示し Reset を案内する（`notifyHost`）

---

### 10. 同期アルゴリズム（フロー）

#### 10.1 初期表示（init）

1. Webview 起動 → `ready` 送信
2. 拡張は `TextDocument.getText()` + `document.version` + `sessionId/clientId` を `init` として返信
3. Webview は Markdown を読み込み、Tiptap を構築

#### 10.2 Webview → TextDocument（編集）

1. ユーザー入力（Tiptap の update など）
2. Webview は debounce（例: 200〜400ms、IME は `compositionend` 優先）し、現在の editor 状態（JSON）を Markdown に serialize して `nextMarkdown` を得る
3. Webview は `shadowText（最後に同期できた Markdown）` と `nextMarkdown` を DiffEngine（例: diff-match-patch）で比較し、Replace[]（0..N 件）を生成する（G5-lite）
   - Replace[] は **非重複・昇順**（offset 範囲置換）に正規化する
   - ChangeGuard: 変更量が大きすぎる場合は自動適用せず、**VS Code 標準通知 UI** に警告を出す（`notifyHost`）
4. in-flight が存在しない場合のみ `edit(baseVersion, txId, changes)` を送信し、in-flight を開始する
   - in-flight 中にさらに編集が起きた場合は送信しない（coalesce フラグのみ立てる）
5. 拡張は `baseVersion === document.version` を検証
   - 一致: `WorkspaceEdit` を適用（`applyEdit`）し、結果に関わらず `ack(txId, currentVersion, outcome)` を返す
     - `outcome=applied`: ドキュメントが変更された
     - `outcome=noop`: 適用結果が 0 差分（P0-4 対応。docChanged が来ないケースがあるため ack が必要）
   - 不一致: `nack(txId, currentVersion, reason=baseVersionMismatch)` を返す
6. `onDidChangeTextDocument` が発火した場合、拡張は全 Webview へ `docChanged` をブロードキャスト（内容変更通知はこれに統一）
   - 追加方針（カーソル安定）: **編集元 Webview には `reason=self` を付与**し、同じ変更で自分自身を再レンダリングしない
7. Webview は `ack` 受信で in-flight を終了する
   - `noop` の場合は `baseVersion = currentVersion` に更新し、即座に次の送信（coalesce flush）へ進める
   - `applied` の場合は `docChanged` を適用して `shadowText` / `baseVersion` を更新する
     - `reason=self` の `docChanged` は **shadowText 更新のみ**を行い、エディタ UI へは反映しない（カーソル末尾ジャンプ対策）
     - `reason=external` の `docChanged` は Webview 側で差分反映（または全文置換）し、他ペインへ追従させる
8. `nack(baseVersionMismatch)` の場合、Webview は `requestResync` を送信し、最新を受け取ってから必要なら **自動で 1 回だけ再送**する（P0-6 対応）

#### 10.3 TextDocument → Webview（外部変更/Undo/他 Webview）

1. `onDidChangeTextDocument` が発火
2. 対象 `docUri` を開いている全 Webview へ `docChanged(version, changes)` を送る
3. Webview は `applyingRemote` を立て、差分を適用（必要なら全文 resync）

---

### 12. Markdown ⇄ Tiptap 変換方針

#### 12.1 初期方針（最短）

- 初期実装は **自前の `MarkdownCodec`**（GFM の主要要素 + frontmatter/HTML/未対応を RAW で保持）で Markdown → Tiptap doc → Markdown を往復する
- **最低限の対応範囲**は `packages/extension/test-fixtures/test.md` をすべて満たす（見出し/リスト/太字/斜体/インラインコード/コードブロック/リンク/画像）
- 将来、互換性の要求が高まった場合は `@tiptap/markdown` / `prosemirror-markdown` への移行を検討する（12.2）

#### 12.1.1 G5-lite（整形保持）を満たすための方針

本プロジェクトは「不要な再整形をしない」をスコープに含めつつ、**厳密な byte-equal 保証（G5 フル）ではなく G5-lite** として実装する。

- **原則**: `TextDocument` の既存 Markdown（`shadowText`）を基準に、**必要最小限のテキスト差分（Replace[]）だけ**を適用する
- **G5-lite の意味**:

  - MarkdownCodec の serialize は canonical 化し得るため、**“未編集箇所が絶対に変わらない”は保証しない**
  - その代わり、`shadowText -> nextMarkdown` の差分を DiffEngine（例: diff-match-patch）で **最小変更に分解**し、不要な再整形を抑える
  - 大規模な書き換えが発生する場合は、ユーザーが気付けるように **確認/停止の導線**を設ける

- **方式（単一）**:

  - Webview は editor 状態（JSON）を Markdown に serialize して `nextMarkdown` を得る（全文）
  - DiffEngine で `shadowText -> nextMarkdown` を比較し Replace[]（0..N 件）を生成する
  - Replace[] は非重複・昇順に正規化し、VS Code 側で `WorkspaceEdit` として適用する

- **異常時（ChangeGuard / DiffEngine）**:
  - DiffEngine 例外や、差分が“過大”である場合は自動適用しない（または危険操作として明示的に確認する）
  - **UI 方針（追加方針）**: エディタ領域は Tiptap に全振りし、Webview 内の全面オーバーレイは使わない
    - 代わりに **VS Code 標準の通知 UI**（非同期/必要に応じてモーダル）で警告を提示する（`notifyHost`）
    - 代表的な導線:
      - **再同期（Resync）**: `requestResyncWithConfirm`（破壊的操作のため確認必須）
      - **Reset Session**: セッション破棄 → `ready → init`
      - **Reopen with Text Editor**: エディタタブ右端のアクション（`editor/title`）から即座に切替
      - **Export Logs**: コマンド `inlineMarkdownEditor.exportLogs` で共有用にエクスポート

※ 編集ブロック内部まで 1:1 を維持するには、converter/serializer の source-preserving 拡張が必要になる可能性がある（必要になればロードマップ化する）。

#### 12.1.2 VS Code 側フォーマッター（formatOnSave 等）との干渉リスク

VS Code で Markdown の formatter が有効な場合（例: Prettier / Markdown All in One / remark 等、`editor.formatOnSave`）、本拡張が「不要な再整形をしない」を目指していても、**保存タイミングで外部要因が Markdown を書き換える**可能性がある。

- **起きうる問題**:

  - **整形が収束しない**: formatter と MarkdownCodec（serialize）の出力方針が異なると、編集 → 保存のたびに同一箇所が書き換わり続ける（ping-pong）
  - **“崩れていく”見え方**: 1 回ごとの変更は小さくても、結果として空行/インデント/番号/折返しが毎回揺れて履歴が荒れる
  - **G5-lite の意図が崩れる**: formatter が外部から広範囲に書き換えると差分が拡大し、不要な再整形が増える

- **本設計の立場**:

  - formatter による変更は **外部変更**として `docChanged` で Webview に反映する（止めない）
  - ただし G5-lite でも、Markdown に対する保存時の自動変更があると ping-pong や差分拡大を誘発するため、保存時の自動変更を無効化する必要がある
  - **必須条件**: これが満たされない場合、本拡張は **利用不可（エディタ起動をブロック）**とする

- **必須（ワークスペース設定）**:

```json
{
  "[markdown]": {
    "editor.formatOnSave": false,
    "editor.formatOnType": false,
    "editor.formatOnPaste": false,
    "editor.codeActionsOnSave": {},
    "files.trimTrailingWhitespace": false,
    "files.insertFinalNewline": false
  }
}
```

- **実装側の対策（あるべき挙動）**:
  - `workspace.isTrusted === false` の場合は、設定変更/画像解決/HTML レンダリング等の安全性が担保できないため、**本拡張の編集 UI を起動せず**「Workspace を Trust してください」エラーを表示する
  - `resolveCustomTextEditor` 時に必須条件（上記）を検証し、満たされない場合は **編集 UI を起動しない**
  - 代わりにブロッキングモーダルを表示する:
    - **適用して続行**: 設定の書き換え前に「変更するキー一覧（現在値 → 適用値）」を表示する **確認モーダル**を出し、承認された場合のみ `Inline Markdown: Apply Required Markdown Settings (G5)` を実行してワークスペース設定へ必須設定を **マージ適用**
    - **設定 UI を開く**: Settings UI を開き、必須キー（`editor.formatOnSave` 等）でフィルタする
    - **キャンセル**: 「このままでは本拡張は利用できない」旨の **確認モーダル**を出す
      - **戻る**: ブロッキングモーダルへ戻る
      - **キャンセルして閉じる**: 本拡張は利用不可のまま（Webview はエラー表示のみ。エディタタブ右端の "Reopen with Text Editor" で退避できる）
  - 重要: 設定の書き換えは **Workspace/WorkspaceFolder** のみに限定し、User(Global) は変更しない
  - UX 対策（P1-1）:
    - 設定を書き換える前に必ず確認モーダルを出し、**どのキーを変更するか（差分）**を明示する（チームポリシーで設定変更できない場合の納得感を上げる）
  - 補足: `editor.codeActionsOnSave: {}` は、Markdown での save 時 Code Action を **言語スコープで上書き無効化**する意図（G5-lite のため）
  - formatter 由来と推定できる “広範囲の docChanged” はログに明示し、原因切り分けを容易にする

#### 12.2 互換性が問題化した場合（堅牢寄り）

- ProseMirror の `prosemirror-markdown` をベースにスキーマ整合を取る
- コストは上がるが、CommonMark 相当の堅牢性を得やすい

#### 12.3 非対応/危険要素の扱い（HTML/リンク/画像）

方針：**デフォルトは “非対応情報（RAW）として扱い”、オプションで安全にレンダリングする。**

##### 12.3.1 HTML（XSS 起点）: デフォルト非レンダリング

- Markdown は HTML を含められるため、Webview 上でそのままレンダリングすると XSS の足場になり得る（P0-2）
- **デフォルト**: HTML ブロック/インライン HTML を **RAW ブロック（編集可能）**として表示し、HTML としてはレンダリングしない
- **オプション**: `inlineMarkdownEditor.security.renderHtml` を有効化した場合のみ、HTML を **サニタイズしてレンダリング**する
  - サニタイズは DOMPurify 等で「許可タグ/属性のホワイトリスト」方式
  - `script`/イベントハンドラ/危険 URL スキームは常に拒否

##### 12.3.2 リンク（危険スキーム禁止 + openExternal）

- **常に禁止**: `javascript:` / `command:` / `vscode:` / `file:` 等の危険スキーム
- **許可（案）**: `https:` / `http:` / `mailto:`（必要なら allowlist）
- Webview 内でのリンククリックは直接遷移せず、extension へ通知して `vscode.env.openExternal` で開く
  - UX: VS Code の慣習に合わせ **Ctrl/Cmd+Click** で開く（通常クリックは編集優先）
  - リモートリンクは確認ダイアログを挟む（設定で抑制可）

##### 12.3.3 画像（ワークスペース内は許可、リモートはオプション）

- **ワークスペース内画像（許可）**:
  - `![](./img.png)` 等を表示できるようにする（P0-5）
  - 解決は extension 側で行い、`asWebviewUri` で Webview 用 URI に変換して返す
  - Webview は DOM 上の `img[src]` を監視し、相対パスを検出したら `resolveImage(requestId, src)` を送る → `imageResolved(requestId, resolvedSrc)` を受けて `img.src` を更新する（同一 src はキャッシュして再利用）
  - `localResourceRoots` は trusted workspace の場合に `workspaceFolders` を追加して許可する（8.1）
  - セキュリティ: ワークスペース外へ抜けるパス（例: `../`）は拒否し、解決できない場合は元の `src` を維持する
- **リモート画像（オプション）**:
  - `inlineMarkdownEditor.security.allowRemoteImages` を有効化した場合のみ許可（trusted workspace のみ）
    - 既定: `https:` のみ許可
    - 追加オプション: `inlineMarkdownEditor.security.allowInsecureRemoteImages=true` で `http:` も許可（強い非推奨）
  - CSP の `img-src` に `https:`（必要なら allowlist）を追加し、`allowInsecureRemoteImages` の場合は追加で `http:` を許可する

##### 12.3.4 非対応記法の扱い（frontmatter 等）

方針：**RAW ブロックで保全し、フォールバックは提供しない。**

- frontmatter など変換不能/非対応の領域を検出したら、その領域を “RAW ブロック” として保持し、保存時にそのまま復元する
- RAW ブロックは Webview 内で **編集可能**とし、保存（TextDocument 反映）は **常に許可**する
- その代わり「非対応記法の完全保全」は非ゴールであることを明記し、変換の制約は既知のリスクとして扱う

補足（編集性優先）：

- RAW ブロックは **編集可能**とし、保存（TextDocument 反映）は **常に許可**する
- デフォルト非レンダリングの情報は「失われない」ことを優先し、視覚表現はオプションとする

---

### 13. Webview ライフサイクルと状態永続化

- **UX 方針（追加方針）**: タブ移動での「再描画感」を抑えるため、デフォルトで `retainContextWhenHidden: true` を採用する
  - ただし最適化オプションとして `inlineMarkdownEditor.webview.retainContextWhenHidden` で **OFF にできる**
    - **OFF の効果**: 大幅なメモリ削減につながる可能性がある
    - **OFF の副作用**: タブ切り替えで Webview が破棄されやすくなり、戻ったときに再描画（再初期化）が発生し得る
    - 注意: 設定変更は WebviewOptions の都合上、**Window Reload が必要**
  - **メリット**: タブ切替で Webview が破棄されにくく、フォーカス/スクロール/編集中の体験が安定する
  - **デメリット**: 非表示中も Webview のメモリを保持しやすい（大きいドキュメント/多数タブで増える）
  - 代替案（必要時）: `retainContextWhenHidden: false` + `getState/setState` による状態復元（ただし視覚的な再構築は起こり得る）
- `getState/setState` で以下を保存する
  - スクロール位置
  - 選択（可能なら）
  - UI 状態（ツールバー開閉等）
- Webview がリロード/復帰した場合は `ready → init` で再同期する（状態は補助）

#### 13.1 復元フロー（VS Code 再起動/タブ復元を想定）

- Webview がリロード/復元された場合でも、Extension 側は `resolveCustomTextEditor` を通じて必ず `init` を送れる設計にする
- Webview は `init.sessionId` を保持し、異なる `sessionId` のメッセージは破棄する（古いメッセージの混入防止）
- `setState` の内容は UI 補助であり、ドキュメント内容の整合は常に `init` / `docChanged` を正とする

---

### 14. VS Code テーマ追従/UI ガイドライン

- `body` に付与される `vscode-light / vscode-dark / vscode-high-contrast` を利用して CSS を分岐
- `--vscode-*` CSS 変数を優先利用し、背景/文字/選択色を VS Code に寄せる
- 可能ならフォントも VS Code の設定に寄せる（CSS 変数や継承を活用）

#### 14.1 推奨の対応表（Tiptap UI → VS Code CSS 変数）

| 用途（Tiptap 側）                   | 参照する VS Code CSS 変数                          |
| ----------------------------------- | -------------------------------------------------- |
| エディタ背景                        | `var(--vscode-editor-background)`                  |
| 本文文字色                          | `var(--vscode-editor-foreground)`                  |
| フォントファミリ                    | `var(--vscode-editor-font-family)`                 |
| フォントサイズ                      | `var(--vscode-editor-font-size)`                   |
| フォントウェイト                    | `var(--vscode-editor-font-weight)`                 |
| キャレット色                        | `var(--vscode-editorCursor-foreground)`            |
| 選択範囲背景                        | `var(--vscode-editor-selectionBackground)`         |
| 非アクティブ選択背景                | `var(--vscode-editor-inactiveSelectionBackground)` |
| 現在行ハイライト                    | `var(--vscode-editor-lineHighlightBackground)`     |
| リンク（通常）                      | `var(--vscode-textLink-foreground)`                |
| リンク（hover/active）              | `var(--vscode-textLink-activeForeground)`          |
| 弱い罫線（リストマーカー/引用線等） | `var(--vscode-editorIndentGuide-background)` など  |

#### 14.2 実装ルール（必須）

- Tiptap の CSS に **固定色を置かない**（すべて `--vscode-*` を参照する）
- **本文は日本語を標準に可読幅で中央寄せ**（例: `max-width: 860px; margin: 0 auto;`）
- **フォーカス枠は不要**（ProseMirror/Tiptap の outline/box-shadow を付けない）
- toolbar / overlay / modal も同様に `--vscode-*` を参照する（`editorWidget.*` / `button.*` 等）

例（概念）：

```css
.inlineMarkdownEditorRoot {
  background: var(--vscode-editor-background);
  color: var(--vscode-editor-foreground);
  font-family: var(--vscode-editor-font-family);
  font-size: var(--vscode-editor-font-size);
  font-weight: var(--vscode-editor-font-weight);
}

.inlineMarkdownEditorRoot a {
  color: var(--vscode-textLink-foreground);
}

.inlineMarkdownEditorRoot a:hover {
  color: var(--vscode-textLink-activeForeground);
}
```

#### 14.3 注: VS Code のシンタックス色（トークン色）完全一致は要件外

- UI 色（背景/前景/選択/リンク/罫線など）の追従は行う
- ただし “VS Code 本体のトークン色と完全一致” はテーマ/言語文法に依存し、Webview 側での完全追従は困難なため要件外とする

---

### 15. ログ/診断（検証フェーズ向け）

実装開始時は「壊れやすい箇所（version 不一致/ループ/整形崩れ）」の切り分けが重要なため、拡張側に診断ログを用意します。

#### 15.1 出力先

- **OutputChannel**（例: “Inline Markdown Editor”）
  - すぐ見たいログ（エラー/重要イベント）を出す
- **JSONL（デバッグオプション / 1 セッション 1 ファイル）**
  - 再現性・共有性のための構造化ログ（時系列で機械処理しやすい）
  - **デフォルトは出力しない**（`inlineMarkdownEditor.debug.enabled=false` または `debug.logToJsonl=false`）。有効化された場合のみ出力する
  - 出力先は拡張の保存領域（例: `context.globalStorageUri` / `context.logUri`）配下

#### 15.2 ログレベル（案）

- `INFO` / `DEBUG` / `TRACE` / `WARN` / `ERROR`

#### 15.3 記録項目（必須）

- `ts`（ISO8601 or ms）, `level`, `event`
- `sessionId`, `clientId`, `docUri`
- `docVersion`（current/base/applied）, `txId`
- `changes`（件数、総文字数、start/end の範囲サマリ）
- `durationMs`
- `errorCode`, `errorStack`（ERROR の場合）

#### 15.4 内容ログの方針（デフォルトは安全側）

- デフォルトは **全文の Markdown をログに残さない**
  - 代わりに length / 先頭数十文字 / ハッシュ（任意）などのメタ情報を残す
- 必要な場合のみ設定で「内容ログ」を明示的に許可する（デバッグ用途）

#### 15.5 重点ログ（この設計で必須）

- `edit` 送信/受信（txId/baseVersion/docVersion/changes サマリ）
- `ack`（txId/currentVersion/outcome）
- `nack`（reason と currentVersion）
- `docChanged`（version/changes と配信先パネル数）
- `requestResync` の発生回数と原因
- **整形保持（G5-lite）**に関わる差分メトリクス（変更率/ハンク数/大規模変更の検出と確認モーダルの結果）
- `error`（`SYNC_TIMEOUT` / `PROTOCOL_VERSION_MISMATCH` / `CODEC_*` / `APPLY_EDIT_*` / `DIFF_ENGINE_FAILED` / `CHANGE_GUARD_EXCEEDED` 等）

#### 15.6 Webview からのログ収集（デバッグオプション）

- Webview は `logClient` で診断ログを送れる（`debug.enabled=true` の場合のみ）
- Extension は受信ログを JSONL に統合し、時系列で追えるようにする

#### 15.7 ログのローテーション/最大サイズ/自動削除（JSONL 有効時の運用必須）

- JSONL は肥大化しやすいため、次を設ける
  - **最大ファイルサイズ**（例: 5MB）
  - **最大ファイル数**（例: 20）
  - **保持期間**（例: 7 日）
- 上限を超えたログは古い順に削除する

#### 15.8 Export Logs のマスキング（共有導線）

- `Export Logs` はデフォルトで **マスキング**して出力する
  - パスは workspace 相対にする、またはハッシュ化する
  - 内容は原則含めない（含める場合は `debug.logContent` の明示許可が必要）

---

### 16. エラー処理ポリシー（フォールバック禁止 / 完全リセット）

#### 16.1 基本方針

- **フォールバック禁止**: 自動で標準テキストエディタへ切替えない
- **エラーは必ず顕在化**: エディタ領域は Tiptap に全振りし、**VS Code 標準通知 UI**（`notifyHost`）で原因と復旧手段を提示する
  - 例外: 起動前提（Workspace trust/必須設定）を満たさない場合は Webview に **簡易エラー HTML** を表示する
- **不整合は完全リセット**: 状態が壊れた場合はセッションを破棄して再初期化する（Reset）

#### 16.2 エラーの扱い（例）

- **Protocol**: `v` 不一致 / 必須フィールド欠落 / 型不正 → `error(code=PROTOCOL_*)`
- **Sync**: `edit` 送信後に `ack`/`nack` が timeoutMs 以内に来ない → `error(code=SYNC_TIMEOUT)`
- **Apply**: `WorkspaceEdit` 適用失敗 → `error(code=APPLY_EDIT_FAILED)`
- **Codec**: Markdown parse/serialize 例外 → `error(code=CODEC_*)`
- **DiffEngine**: diff 生成に失敗（例外/不正な Replace[]）→ `error(code=DIFF_ENGINE_FAILED)`
- **ChangeGuard**: 変更量が閾値を超過 → **VS Code 標準通知 UI** で `CHANGE_GUARD_EXCEEDED` を提示（`notifyHost`）
- **Trust**: workspace が untrusted（Restricted Mode） → `error(code=WORKSPACE_UNTRUSTED)`

#### 16.3 復旧導線（ユーザー操作）

- **Soft（推奨）**: `requestResync`（同一セッション内で再同期）
- **Hard（完全リセット）**: `Reset Editor Session`（Webview 状態を破棄して `init` からやり直し）
- **手動退避**: VS Code の “Reopen with Text Editor” で標準エディタへ切替（自動では行わない）
- **診断共有**: ログのエクスポート（Export Logs）

---

### 17. 設定 / コマンド（案）

#### 17.1 設定（Configuration）

- **`inlineMarkdownEditor.sync.debounceMs`**（number, default: 250）
  - Webview の送信デバウンス
- **`inlineMarkdownEditor.sync.timeoutMs`**（number, default: 3000）
  - in-flight の確定待ちタイムアウト（`ack`/`nack` を待つ）
- **`inlineMarkdownEditor.sync.changeGuard.maxChangedRatio`**（number, default: 0.5）
  - 変更率（概算）がこの値を超えた場合、`CHANGE_GUARD_EXCEEDED` として扱う
- **`inlineMarkdownEditor.sync.changeGuard.maxChangedChars`**（number, default: 50000）
  - 変更文字数（概算）がこの値を超えた場合、`CHANGE_GUARD_EXCEEDED` として扱う
- **`inlineMarkdownEditor.sync.changeGuard.maxHunks`**（number, default: 200）
  - Replace[] の件数がこの値を超えた場合、`CHANGE_GUARD_EXCEEDED` として扱う
- **`inlineMarkdownEditor.debug.enabled`**（boolean, default: false）
  - デバッグモード（拡張/ Webview の診断ログ、必要に応じて JSONL 出力）をまとめて ON/OFF
- **`inlineMarkdownEditor.debug.logLevel`**（string, default: `INFO`）
  - `INFO|DEBUG|TRACE|WARN|ERROR`
- **`inlineMarkdownEditor.debug.logToJsonl`**（boolean, default: false）
  - JSONL の出力（デバッグ用途。デフォルトは無効）
- **`inlineMarkdownEditor.debug.jsonlMaxBytes`**（number, default: 5000000）
  - JSONL 1 ファイルの最大サイズ（超過時はローテーション）
- **`inlineMarkdownEditor.debug.jsonlMaxFiles`**（number, default: 20）
  - JSONL の最大ファイル数（超過時は古い順に削除）
- **`inlineMarkdownEditor.debug.jsonlRetentionDays`**（number, default: 7）
  - JSONL の保持期間（日）
- **`inlineMarkdownEditor.debug.logContent`**（boolean, default: false）
  - Markdown 内容のログ（デフォルトは無効）
- **`inlineMarkdownEditor.security.allowWorkspaceImages`**（boolean, default: true）
  - ワークスペース内画像（`![](./img.png)` 等）を表示する（trusted workspace のみ）
- **`inlineMarkdownEditor.security.allowRemoteImages`**（boolean, default: false）
  - リモート画像（`https:`）の読み込みを許可する（trusted workspace のみ）
- **`inlineMarkdownEditor.security.allowInsecureRemoteImages`**（boolean, default: false）
  - リモート画像（`http:`）の読み込みを許可する（trusted workspace のみ。**強い非推奨**）
- **`inlineMarkdownEditor.security.renderHtml`**（boolean, default: false）
  - HTML をサニタイズしてレンダリングする（デフォルトは RAW ブロック扱い）
- **`inlineMarkdownEditor.security.confirmExternalLinks`**（boolean, default: true）
  - リモートリンクを開く前に確認ダイアログを表示する
- **`inlineMarkdownEditor.webview.retainContextWhenHidden`**（boolean, default: true）
  - タブ切り替え時に Webview を保持して UX を向上する
  - OFF にするとメモリ削減につながる可能性があるが、戻ったときに再描画（再初期化）が発生し得る
  - 変更は Window Reload が必要（WebviewOptions の都合）

#### 17.2 コマンド（Command）

- **Inline Markdown: Reset Editor Session**
  - Hard reset（Webview 状態を破棄して `init` からやり直し）
- **Inline Markdown: Reopen with Text Editor**
  - エディタタブ右端（`editor/title`）にアイコンとして配置し、ワンクリックで標準テキストエディタへ切り替える
  - 実装は `workbench.action.reopenTextEditor` を優先し、失敗時は `vscode.openWith(uri, 'default')` にフォールバックする（o3 推奨）
- **Inline Markdown: Apply Required Markdown Settings (G5)**
  - 適用前に確認モーダル（変更するキー一覧）を表示し、承認された場合のみワークスペース設定の `[markdown]` に必須設定（例: `editor.formatOnSave=false`, `editor.codeActionsOnSave={}`, `files.trimTrailingWhitespace=false`, `files.insertFinalNewline=false`）を適用する（既存設定はマージ）
- **Inline Markdown: Export Logs**
  - JSONL/診断情報をエクスポート（共有/Issue 添付用）

---

### 18. セキュリティチェックリスト

- 依存（JS/CSS）は **拡張に同梱**し、CDN には依存しない
- `localResourceRoots` はデフォルト `media/webview` に限定し、**ワークスペース内画像を許可する場合のみ** `workspaceFolders` を追加する（trusted workspace のみ）
- HTML リソース参照は `asWebviewUri()` 経由のみ
- CSP: `default-src 'none'` + nonce による script 制約
- HTML はデフォルト非レンダリング（RAW）。レンダリングする場合は DOMPurify 等でサニタイズ（12.3）
- 危険リンクスキーム（`javascript:`/`command:` 等）は禁止し、リンクは `openExternal` 経由で開く（12.3）
- リモート画像はデフォルト禁止。許可する場合は既定で `https:` のみに制限し、`allowInsecureRemoteImages` の場合のみ `http:` も許可する（trusted workspace のみ。強い非推奨）
- workspace が untrusted（Restricted Mode）の場合は、編集 UI を起動しない（16.2/12.1.2）
- Webview message は `type` をホワイトリスト検証し、想定外メッセージを無視する
- `acquireVsCodeApi()` の返り値をグローバルに露出しない（モジュール内に閉じる）

---

### 19. パフォーマンス設計（最低限）

- Webview→ 拡張の edit 送信は debounce（200〜400ms を目安、IME 配慮）
- 初期から DiffEngine（例: diff-match-patch）で Replace[] を生成し、最小変更として適用する（単一戦略）
- 大きいドキュメントでは `docChanged` の差分適用が重要（全文再送を避ける）
- 大きい Markdown（例: 行数/サイズが閾値超え）の場合は、初期は **警告**で対応する
- **疑似仮想化（CSS）は初期対応の必須要件**:

  - `content-visibility: auto`（＋`contain-intrinsic-size`）等で、DOM は残したまま描画/レイアウト負荷を下げる
  - 目的: 「真の仮想化（viewport 外 DOM を消す）」が難しい前提でも、巨大 Markdown のスクロール/描画を現実的にする
  - 注意: 互換性/挙動差（ブラウザ実装差）を考慮し、効果が薄い環境では警告にフォールバックする

- **ロードマップ: 折りたたみ（placeholder 置換で“描画しない”）**:
  - 見出し配下などを折りたたみ、対象範囲をプレースホルダ表示に **置換**して DOM 生成自体を抑える（効果が大きい）
  - `display:none` による「表示だけ隠す」方式は、本設計では採用しない（疑似仮想化と役割が重なるため）

---

### 20. テスト計画

#### 20.1 手動テスト（初期）

- 必須のワークスペース設定（12.1.2）が未適用の場合、本拡張が **起動をブロック**し、`Apply Required Markdown Settings (G5)` で適用後に編集できる
- `.md` を開くと Webview（Tiptap）が表示される
- `packages/extension/test-fixtures/test.md` の記法（見出し/箇条書き/太字/斜体/インラインコード/コードブロック/リンク/画像）が崩れずに編集できる
- 編集すると保存前でも Dirty が立ち、保存で Markdown が更新される
- 入力直後に「自分の docChanged」で再レンダリングされず、**カーソルが末尾へ飛ばない**
- Split 表示で同一ファイルを開き、片方で編集するともう片方が追従する
- テキストエディタ（標準）に “Reopen with Text Editor” して編集すると、Webview が追従する
- エディタタブ右端に **Reopen with Text Editor** アイコンが出て、ワンクリックで標準テキストエディタへ切り替えられる
- **0 差分（no-op）** の edit でも in-flight が解放され、timeout→resync ループにならない（ack の確認）
- HTML はデフォルト RAW 表示で、`security.renderHtml=true` の場合のみサニタイズされて表示される
- `![](./img.png)` のワークスペース画像が表示される（trusted workspace）
- リモート画像はデフォルト非表示で、`security.allowRemoteImages=true` の場合のみ表示される
- `security.allowInsecureRemoteImages=true` の場合、`http:` のリモート画像も表示される（強い非推奨）
- リンクは Webview 内で直接遷移せず、**Ctrl/Cmd+Click** で `openExternal` により開く（危険スキームは拒否）
- Undo/Redo が破綻しない（少なくとも一定の粒度で戻れる）
- VS Code テーマ（light/dark）で視認性が維持される
- 大きい Markdown で `content-visibility` による疑似仮想化が有効に働き、スクロール/描画が破綻しない
- ChangeGuard（大規模変更検出）は **VS Code 標準通知 UI** で警告される（エディタ領域に全面 UI を被せない）
- タブ切替で Webview が破棄されにくく、戻ってきたときに「再描画感」がない（`retainContextWhenHidden: true`）

---

### 21. 決定事項（本設計の前提）

- **U1**: `.md` の乗っ取り強度は **`default`**
- **U2**: frontmatter 等は **RAW ブロックとして保全**（フォールバック無し）
- **U3**: 同期は **Replace[] 差分**を採用（DiffEngine: diff-match-patch 等で生成）
- **U4**: G5-lite（不要な再整形の抑止）と同期安定性のため、Markdown の保存時自動変更を無効化する必須ワークスペース設定（12.1.2）が未適用の場合は **本拡張を利用不可**とする
- **U5**: HTML はデフォルト RAW（非レンダリング）。ワークスペース内画像は許可し、リモート画像はオプションで許可する（12.3）
- **U6**: 文字列ローカライズ方針（22）
  - **拡張機能名（displayName/custom editor displayName）は英語固定**（全ロケール共通）
  - 設定/コマンド/通知/モーダル/エラー表示などのユーザー向け文字列は **英語・日本語・中国語**にローカライズする

---

### 22. ローカライズ（i18n: en/ja/zh）

目的: VS Code の Settings UI / Command Palette / 通知/モーダル/エラー表示が、英語・日本語・中国語で自然に読めること。

方針:

- **識別子はローカライズしない**:
  - setting key（例: `inlineMarkdownEditor.sync.timeoutMs`）/ command id は固定（英数字）とする
  - ローカライズ対象は **表示名/説明/メッセージ**のみ
  - 例外（追加方針）: **拡張機能名（displayName/custom editor displayName）は英語固定**（全ロケール共通）

実装（VS Code 公式の仕組みに準拠）:

- **Contribution（`package.json` の contributes）**:
  - コマンド title/category、設定の title/description 等は `%key%` 参照にし、`package.nls.json`（英語）と `package.nls.ja.json` / `package.nls.zh-cn.json` に翻訳を置く
- **Runtime 文字列（extension host の通知/モーダル/エラー文言）**:
  - `vscode.l10n.t(...)` を使用する
  - `package.json` に `"l10n": "./l10n"` を宣言し、`l10n/bundle.l10n.json`（英語）と `bundle.l10n.ja.json` / `bundle.l10n.zh-cn.json` を同梱する
- **Webview UI 文字列（最小限の文言）**:
  - （追加方針）エディタ領域の全面オーバーレイ UI は使わず、警告/エラーは VS Code 通知 UI に寄せる
  - Webview 起動時に extension 側から `locale`（`vscode.env.language`）と最小の i18n bundle を渡す（`init` に含める等）
  - Webview はその bundle を用いて表示文字列を切り替える（外部通信なし）

注:

- 中国語はまず `zh-cn`（簡体字）を対象とし、必要になれば `zh-tw`（繁体字）を追加する

---

### 23. 追加方針（UX/設計見直しの論点）

#### 23.1 入力直後にカーソルが末尾へ飛ぶ問題（再レンダリング問題）

**現象**: 1 文字入力した瞬間に UI が再構築され、キャレットが末尾へ移動してしまう。  
**本質**: 「TextDocument を唯一の真実にしたい」一方で、毎キー入力で Webview 側が `setContent` 相当の再構築をすると ProseMirror の selection が失われる。

**解決策の選択肢**（慎重に比較）:

- **A: 自分起因の `docChanged` は UI に反映しない（`reason=self`）**（採用）
  - **やり方**:
    - Extension 側で「この `document.version` はどの clientId が作ったか」を追跡し、編集元 Webview へは `docChanged.reason=self` を送る
    - Webview 側は `reason=self` の `docChanged` を **shadowText 更新のみ**にして UI へ適用しない
  - **メリット**: 最小改修でキャレットジャンプを根絶しやすい。split 同期も維持できる
  - **デメリット**: 「UI が真実」ではなく「UI と shadowText の二重管理」になるため、実装の規律（in-flight/flush の順序）が重要

- **B: `docChanged` を ProseMirror transaction として適用（selection を保つ）**
  - **メリット**: “再構築” を避けられるので体験が最も自然になり得る
  - **デメリット**: Markdown テキスト差分（Replace[]）→ ProseMirror transaction のマッピングが難しい（変換品質が必要）

- **C: 再構築するが selection を保存/復元する**
  - **メリット**: 実装は比較的単純
  - **デメリット**: 位置がズレる/失敗するケースが多い（IME・置換・構文変換・行折返しなど）ため、根本解決になりにくい

- **D: “TextDocument を唯一の真実” をやめて、Webview 側を真実に寄せる（CRDT 等）**
  - **メリット**: 編集体験は作りやすい
  - **デメリット**: VS Code の標準 Undo/Redo/Hot Exit・他拡張との整合が大きく難しくなる（本プロジェクトの方針に反する）

#### 23.2 タブ移動で「再描画感」が出る問題（UX）

**選択肢**:

- **A: `retainContextWhenHidden: true`**（採用）
  - **メリット**: タブ切替で Webview が破棄されにくく、体験が安定
  - **デメリット**: メモリ使用量が増える

- **B: `retainContextWhenHidden: false` + `getState/setState` による復元**
  - **メリット**: メモリ効率がよい
  - **デメリット**: DOM/Editor の再初期化は避けられず、再描画感が残る（特に大きい md）

- **C: A を基本にしつつ、巨大ドキュメント時のみ B に落とす**
  - **メリット**: 体験とメモリのバランスを取りやすい
  - **デメリット**: 分岐が増え、設定/判定が複雑化しやすい（本プロジェクト方針的に慎重）

#### 23.3 Tiptap エディタを縦横 100% にする方法（選択肢）

- **A: Flex レイアウト（推奨/採用）**
  - `#app { display:flex; flex-direction:column }`
  - `.editor-container { flex:1; overflow:auto }`
  - `.ProseMirror { height:100% }`
  - **メリット**: 最小/堅牢。VS Code Webview と相性が良い
  - **デメリット**: なし（基本これで良い）

- **B: absolute positioning**
  - **メリット**: 直感的
  - **デメリット**: 親要素の高さ計算/リサイズで崩れやすい

#### 23.4 デバッグ系オプションは 1 つで ON/OFF すべきか

**結論**: すべきです。普段の利用で “必要なときだけ” デバッグを有効化でき、設定が散らばって運用される事故を減らせます。  
**実装方針（スマートでシンプル）**:

- **`inlineMarkdownEditor.debug.enabled`** を master switch として扱う
  - `enabled=false` のときは DEBUG/TRACE 等を出さない（WARN/ERROR は常時出す）
  - JSONL 出力や内容ログも `enabled=true` のときだけ有効（`logToJsonl` 等は “追加条件”）

#### 23.5 パッケージアップデート（最新化）で変わった点（設計への反映）

- **Tiptap v3 系**
  - `StarterKit` に Link 等が含まれるため、重複を避けて **StarterKit 側の link を無効化**し、`@tiptap/extension-link` を明示採用する（`openOnClick:false` 等のセキュリティ設定を確実に適用）
- **Vite v7 系**
  - `build.manifest: true` で `outDir/.vite/manifest.json` が生成される
  - manifest は `isEntry` の chunk に `file`（JS）と `css[]`（CSS）を持つため、拡張側は **`isEntry` の解決**でロード対象を決める
  - VS Code Webview の Chromium バージョンに合わせて `build.target` を明示できる（例: `chrome120`）
- **VS Code（カスタムエディタ）**
  - `contributes.menus.editor/title` + `when: activeCustomEditorId == <viewType>` で、エディタタブ右端にアクションを追加できる（例: Reopen with Text Editor）

---

### 24. 参考（実装開始時に参照）

- [VS Code Custom Editors](https://code.visualstudio.com/api/extension-guides/custom-editors)
- [VS Code Webview](https://code.visualstudio.com/api/extension-guides/webview)

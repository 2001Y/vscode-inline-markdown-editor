# Table DnD 実装相談（o3）(2026-01-10)

## 相談背景
- テーブル行/列の DnD が不安定、もしくは発火しない。
- HTML5 drag は contenteditable 上で不安定になりやすい。
- ProseMirror/Tiptap に寄せた「最小で確実な」DnD 実装を選びたい。

## o3回答の要点
### Option A (推奨): Pointer-based DnD
- HTML5 drag を使わず **pointerdown/move/up** で実装。
- ドラッグ開始時に `anchorCellPos` を確定（セル内部 pos）。
- `TableMap` で `fromIndex` を算出。
- pointermove で `cellAround` から **boundary** を算出してインジケータ表示。
- pointerup で `moveTableRow/Column` を **command(state, dispatch)** で実行。

### Option B: HTML5 drag 継続
- handle だけ draggable にして dragover/drop を自前で処理。
- ただし contenteditable と相性が悪く、イベント欠落が起きやすい。

## 実装指針
- **Row/Col index は DOM ではなく TableMap 基準**で求める。
- `pos` は必ず **セル内** (tableStart+1) を渡す。
- ドラッグ中は `pointer capture` を使いイベントを確実に取得。
- 補助線は行/列どちらか片方だけ表示。

## 進め方
- Option A で TableControls を再実装（pointer DnD）する方針。

## 実装メモ（反映済み）
- `resolveCellPosFromDom` は **pos + 1** を返す（`TextSelection` の endpoint エラー回避）。
- 行/列追加ボタンは `Selection.findFrom` でセル内の TextSelection を確定してから command 実行。
- pointermove は `cellAround($pos)` → `TableMap.findCell` で boundary を計算し、**行/列どちらか片方の補助線のみ表示**。
- `cellDom` 取得は `TableMap.positionAt` で **cellStart** を算出して `view.nodeDOM(cellStart)` を使用。
- DnD の開始/完了は `INFO` / `SUCCESS` ログで **タイムスタンプと所要時間** を必ず出力。
